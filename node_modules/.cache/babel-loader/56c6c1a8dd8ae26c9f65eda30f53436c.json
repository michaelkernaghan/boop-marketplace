{"ast":null,"code":"\"use strict\";\n\n/**\n *  Conversion Utilities\n *\n */\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  }\n  result[\"default\"] = mod;\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar errors = __importStar(require(\"../errors\"));\n///////////////////////////////\nfunction isHexable(value) {\n  return !!value.toHexString;\n}\nexports.isHexable = isHexable;\nfunction addSlice(array) {\n  if (array.slice) {\n    return array;\n  }\n  array.slice = function () {\n    var args = Array.prototype.slice.call(arguments);\n    return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n  };\n  return array;\n}\nfunction isArrayish(value) {\n  if (!value || parseInt(String(value.length)) != value.length || typeof value === 'string') {\n    return false;\n  }\n  for (var i = 0; i < value.length; i++) {\n    var v = value[i];\n    if (v < 0 || v >= 256 || parseInt(String(v)) != v) {\n      return false;\n    }\n  }\n  return true;\n}\nexports.isArrayish = isArrayish;\nfunction arrayify(value) {\n  if (value == null) {\n    errors.throwError('cannot convert null value to array', errors.INVALID_ARGUMENT, {\n      arg: 'value',\n      value: value\n    });\n  }\n  if (isHexable(value)) {\n    value = value.toHexString();\n  }\n  if (typeof value === 'string') {\n    var match = value.match(/^(0x)?[0-9a-fA-F]*$/);\n    if (!match) {\n      errors.throwError('invalid hexidecimal string', errors.INVALID_ARGUMENT, {\n        arg: 'value',\n        value: value\n      });\n    }\n    if (match[1] !== '0x') {\n      errors.throwError('hex string must have 0x prefix', errors.INVALID_ARGUMENT, {\n        arg: 'value',\n        value: value\n      });\n    }\n    value = value.substring(2);\n    if (value.length % 2) {\n      value = '0' + value;\n    }\n    var result = [];\n    for (var i = 0; i < value.length; i += 2) {\n      result.push(parseInt(value.substr(i, 2), 16));\n    }\n    return addSlice(new Uint8Array(result));\n  }\n  if (isArrayish(value)) {\n    return addSlice(new Uint8Array(value));\n  }\n  errors.throwError('invalid arrayify value', null, {\n    arg: 'value',\n    value: value,\n    type: typeof value\n  });\n  return null;\n}\nexports.arrayify = arrayify;\nfunction concat(objects) {\n  var arrays = [];\n  var length = 0;\n  for (var i = 0; i < objects.length; i++) {\n    var object = arrayify(objects[i]);\n    arrays.push(object);\n    length += object.length;\n  }\n  var result = new Uint8Array(length);\n  var offset = 0;\n  for (var i = 0; i < arrays.length; i++) {\n    result.set(arrays[i], offset);\n    offset += arrays[i].length;\n  }\n  return addSlice(result);\n}\nexports.concat = concat;\nfunction stripZeros(value) {\n  var result = arrayify(value);\n  if (result.length === 0) {\n    return result;\n  }\n  // Find the first non-zero entry\n  var start = 0;\n  while (result[start] === 0) {\n    start++;\n  }\n  // If we started with zeros, strip them\n  if (start) {\n    result = result.slice(start);\n  }\n  return result;\n}\nexports.stripZeros = stripZeros;\nfunction padZeros(value, length) {\n  value = arrayify(value);\n  if (length < value.length) {\n    throw new Error('cannot pad');\n  }\n  var result = new Uint8Array(length);\n  result.set(value, length - value.length);\n  return addSlice(result);\n}\nexports.padZeros = padZeros;\nfunction isHexString(value, length) {\n  if (typeof value !== 'string' || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n    return false;\n  }\n  if (length && value.length !== 2 + 2 * length) {\n    return false;\n  }\n  return true;\n}\nexports.isHexString = isHexString;\nvar HexCharacters = '0123456789abcdef';\nfunction hexlify(value) {\n  if (isHexable(value)) {\n    return value.toHexString();\n  }\n  if (typeof value === 'number') {\n    if (value < 0) {\n      errors.throwError('cannot hexlify negative value', errors.INVALID_ARGUMENT, {\n        arg: 'value',\n        value: value\n      });\n    }\n    // @TODO: Roll this into the above error as a numeric fault (overflow); next version, not backward compatible\n    // We can about (value == MAX_INT) to as well, since that may indicate we underflowed already\n    if (value >= 9007199254740991) {\n      errors.throwError(\"out-of-range\", errors.NUMERIC_FAULT, {\n        operartion: \"hexlify\",\n        fault: \"out-of-safe-range\"\n      });\n    }\n    var hex = '';\n    while (value) {\n      hex = HexCharacters[value & 0x0f] + hex;\n      value = Math.floor(value / 16);\n    }\n    if (hex.length) {\n      if (hex.length % 2) {\n        hex = '0' + hex;\n      }\n      return '0x' + hex;\n    }\n    return '0x00';\n  }\n  if (typeof value === 'string') {\n    var match = value.match(/^(0x)?[0-9a-fA-F]*$/);\n    if (!match) {\n      errors.throwError('invalid hexidecimal string', errors.INVALID_ARGUMENT, {\n        arg: 'value',\n        value: value\n      });\n    }\n    if (match[1] !== '0x') {\n      errors.throwError('hex string must have 0x prefix', errors.INVALID_ARGUMENT, {\n        arg: 'value',\n        value: value\n      });\n    }\n    if (value.length % 2) {\n      value = '0x0' + value.substring(2);\n    }\n    return value;\n  }\n  if (isArrayish(value)) {\n    var result = [];\n    for (var i = 0; i < value.length; i++) {\n      var v = value[i];\n      result.push(HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f]);\n    }\n    return '0x' + result.join('');\n  }\n  errors.throwError('invalid hexlify value', null, {\n    arg: 'value',\n    value: value\n  });\n  return 'never';\n}\nexports.hexlify = hexlify;\nfunction hexDataLength(data) {\n  if (!isHexString(data) || data.length % 2 !== 0) {\n    return null;\n  }\n  return (data.length - 2) / 2;\n}\nexports.hexDataLength = hexDataLength;\nfunction hexDataSlice(data, offset, endOffset) {\n  if (!isHexString(data)) {\n    errors.throwError('invalid hex data', errors.INVALID_ARGUMENT, {\n      arg: 'value',\n      value: data\n    });\n  }\n  if (data.length % 2 !== 0) {\n    errors.throwError('hex data length must be even', errors.INVALID_ARGUMENT, {\n      arg: 'value',\n      value: data\n    });\n  }\n  offset = 2 + 2 * offset;\n  if (endOffset != null) {\n    return '0x' + data.substring(offset, 2 + 2 * endOffset);\n  }\n  return '0x' + data.substring(offset);\n}\nexports.hexDataSlice = hexDataSlice;\nfunction hexStripZeros(value) {\n  if (!isHexString(value)) {\n    errors.throwError('invalid hex string', errors.INVALID_ARGUMENT, {\n      arg: 'value',\n      value: value\n    });\n  }\n  while (value.length > 3 && value.substring(0, 3) === '0x0') {\n    value = '0x' + value.substring(3);\n  }\n  return value;\n}\nexports.hexStripZeros = hexStripZeros;\nfunction hexZeroPad(value, length) {\n  if (!isHexString(value)) {\n    errors.throwError('invalid hex string', errors.INVALID_ARGUMENT, {\n      arg: 'value',\n      value: value\n    });\n  }\n  while (value.length < 2 * length + 2) {\n    value = '0x0' + value.substring(2);\n  }\n  return value;\n}\nexports.hexZeroPad = hexZeroPad;\nfunction isSignature(value) {\n  return value && value.r != null && value.s != null;\n}\nfunction splitSignature(signature) {\n  var v = 0;\n  var r = '0x',\n    s = '0x';\n  if (isSignature(signature)) {\n    if (signature.v == null && signature.recoveryParam == null) {\n      errors.throwError('at least on of recoveryParam or v must be specified', errors.INVALID_ARGUMENT, {\n        argument: 'signature',\n        value: signature\n      });\n    }\n    r = hexZeroPad(signature.r, 32);\n    s = hexZeroPad(signature.s, 32);\n    v = signature.v;\n    if (typeof v === 'string') {\n      v = parseInt(v, 16);\n    }\n    var recoveryParam = signature.recoveryParam;\n    if (recoveryParam == null && signature.v != null) {\n      recoveryParam = 1 - v % 2;\n    }\n    v = 27 + recoveryParam;\n  } else {\n    var bytes = arrayify(signature);\n    if (bytes.length !== 65) {\n      throw new Error('invalid signature');\n    }\n    r = hexlify(bytes.slice(0, 32));\n    s = hexlify(bytes.slice(32, 64));\n    v = bytes[64];\n    if (v !== 27 && v !== 28) {\n      v = 27 + v % 2;\n    }\n  }\n  return {\n    r: r,\n    s: s,\n    recoveryParam: v - 27,\n    v: v\n  };\n}\nexports.splitSignature = splitSignature;\nfunction joinSignature(signature) {\n  signature = splitSignature(signature);\n  return hexlify(concat([signature.r, signature.s, signature.recoveryParam ? '0x1c' : '0x1b']));\n}\nexports.joinSignature = joinSignature;","map":null,"metadata":{},"sourceType":"script"}