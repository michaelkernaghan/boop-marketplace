{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar constants_1 = require(\"../constants\");\nvar errors_1 = require(\"../errors\");\nvar bytes_1 = require(\"./bytes\");\n///////////////////////////////\nvar UnicodeNormalizationForm;\n(function (UnicodeNormalizationForm) {\n  UnicodeNormalizationForm[\"current\"] = \"\";\n  UnicodeNormalizationForm[\"NFC\"] = \"NFC\";\n  UnicodeNormalizationForm[\"NFD\"] = \"NFD\";\n  UnicodeNormalizationForm[\"NFKC\"] = \"NFKC\";\n  UnicodeNormalizationForm[\"NFKD\"] = \"NFKD\";\n})(UnicodeNormalizationForm = exports.UnicodeNormalizationForm || (exports.UnicodeNormalizationForm = {}));\n;\n// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array\nfunction toUtf8Bytes(str, form) {\n  if (form === void 0) {\n    form = UnicodeNormalizationForm.current;\n  }\n  if (form != UnicodeNormalizationForm.current) {\n    errors_1.checkNormalize();\n    str = str.normalize(form);\n  }\n  var result = [];\n  for (var i = 0; i < str.length; i++) {\n    var c = str.charCodeAt(i);\n    if (c < 0x80) {\n      result.push(c);\n    } else if (c < 0x800) {\n      result.push(c >> 6 | 0xc0);\n      result.push(c & 0x3f | 0x80);\n    } else if ((c & 0xfc00) == 0xd800) {\n      i++;\n      var c2 = str.charCodeAt(i);\n      if (i >= str.length || (c2 & 0xfc00) !== 0xdc00) {\n        throw new Error('invalid utf-8 string');\n      }\n      // Surrogate Pair\n      c = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\n      result.push(c >> 18 | 0xf0);\n      result.push(c >> 12 & 0x3f | 0x80);\n      result.push(c >> 6 & 0x3f | 0x80);\n      result.push(c & 0x3f | 0x80);\n    } else {\n      result.push(c >> 12 | 0xe0);\n      result.push(c >> 6 & 0x3f | 0x80);\n      result.push(c & 0x3f | 0x80);\n    }\n  }\n  return bytes_1.arrayify(result);\n}\nexports.toUtf8Bytes = toUtf8Bytes;\n;\n// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499\nfunction toUtf8String(bytes, ignoreErrors) {\n  bytes = bytes_1.arrayify(bytes);\n  var result = '';\n  var i = 0;\n  // Invalid bytes are ignored\n  while (i < bytes.length) {\n    var c = bytes[i++];\n    // 0xxx xxxx\n    if (c >> 7 === 0) {\n      result += String.fromCharCode(c);\n      continue;\n    }\n    // Multibyte; how many bytes left for this character?\n    var extraLength = null;\n    var overlongMask = null;\n    // 110x xxxx 10xx xxxx\n    if ((c & 0xe0) === 0xc0) {\n      extraLength = 1;\n      overlongMask = 0x7f;\n      // 1110 xxxx 10xx xxxx 10xx xxxx\n    } else if ((c & 0xf0) === 0xe0) {\n      extraLength = 2;\n      overlongMask = 0x7ff;\n      // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx\n    } else if ((c & 0xf8) === 0xf0) {\n      extraLength = 3;\n      overlongMask = 0xffff;\n    } else {\n      if (!ignoreErrors) {\n        if ((c & 0xc0) === 0x80) {\n          throw new Error('invalid utf8 byte sequence; unexpected continuation byte');\n        }\n        throw new Error('invalid utf8 byte sequence; invalid prefix');\n      }\n      continue;\n    }\n    // Do we have enough bytes in our data?\n    if (i + extraLength > bytes.length) {\n      if (!ignoreErrors) {\n        throw new Error('invalid utf8 byte sequence; too short');\n      }\n      // If there is an invalid unprocessed byte, skip continuation bytes\n      for (; i < bytes.length; i++) {\n        if (bytes[i] >> 6 !== 0x02) {\n          break;\n        }\n      }\n      continue;\n    }\n    // Remove the length prefix from the char\n    var res = c & (1 << 8 - extraLength - 1) - 1;\n    for (var j = 0; j < extraLength; j++) {\n      var nextChar = bytes[i];\n      // Invalid continuation byte\n      if ((nextChar & 0xc0) != 0x80) {\n        res = null;\n        break;\n      }\n      ;\n      res = res << 6 | nextChar & 0x3f;\n      i++;\n    }\n    if (res === null) {\n      if (!ignoreErrors) {\n        throw new Error('invalid utf8 byte sequence; invalid continuation byte');\n      }\n      continue;\n    }\n    // Check for overlong seuences (more bytes than needed)\n    if (res <= overlongMask) {\n      if (!ignoreErrors) {\n        throw new Error('invalid utf8 byte sequence; overlong');\n      }\n      continue;\n    }\n    // Maximum code point\n    if (res > 0x10ffff) {\n      if (!ignoreErrors) {\n        throw new Error('invalid utf8 byte sequence; out-of-range');\n      }\n      continue;\n    }\n    // Reserved for UTF-16 surrogate halves\n    if (res >= 0xd800 && res <= 0xdfff) {\n      if (!ignoreErrors) {\n        throw new Error('invalid utf8 byte sequence; utf-16 surrogate');\n      }\n      continue;\n    }\n    if (res <= 0xffff) {\n      result += String.fromCharCode(res);\n      continue;\n    }\n    res -= 0x10000;\n    result += String.fromCharCode((res >> 10 & 0x3ff) + 0xd800, (res & 0x3ff) + 0xdc00);\n  }\n  return result;\n}\nexports.toUtf8String = toUtf8String;\nfunction formatBytes32String(text) {\n  // Get the bytes\n  var bytes = toUtf8Bytes(text);\n  // Check we have room for null-termination\n  if (bytes.length > 31) {\n    throw new Error('bytes32 string must be less than 32 bytes');\n  }\n  // Zero-pad (implicitly null-terminates)\n  return bytes_1.hexlify(bytes_1.concat([bytes, constants_1.HashZero]).slice(0, 32));\n}\nexports.formatBytes32String = formatBytes32String;\nfunction parseBytes32String(bytes) {\n  var data = bytes_1.arrayify(bytes);\n  // Must be 32 bytes with a null-termination\n  if (data.length !== 32) {\n    throw new Error('invalid bytes32 - not 32 bytes long');\n  }\n  if (data[31] !== 0) {\n    throw new Error('invalid bytes32 string - no null terminator');\n  }\n  // Find the null termination\n  var length = 31;\n  while (data[length - 1] === 0) {\n    length--;\n  }\n  // Determine the string value\n  return toUtf8String(data.slice(0, length));\n}\nexports.parseBytes32String = parseBytes32String;","map":null,"metadata":{},"sourceType":"script"}